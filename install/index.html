<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Adamantine by Rombur</title>

    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/github-dark.css">
    <script src="../javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header class="without-description">
        <h1>Adamantine</h1>
        <p></p>
      </header>
      <section>
        <h2>Installation</h2>
          <p>
          Installing <i>adamantine</i> requires:
          <ul>
            <li> CMake (at least version 3.0) </li>
            <li> Boost (at least version 1.59) </li>
            <li> p4est (at least version 1.0) </li>
            <li> deal.II (development version) </li>
          </ul>
          </p>
          <p>The simplest way to install adamantine's TPL is to use 
          <a href="https://github.com/llnl/spack">spack</a> and to type the 
          following commands:
          <ul>
            <li> <strong> spack install boost+graph+icu+mpi </strong> </li>
            <li> <strong> spack install
                dealii@develop~arpack~gsl~hdf5~metis~netcdf~oce~petsc~python~slepc~trilinos+mpi 
                ^boost+graph+icu+mpi</strong> </li>
          </ul>
           Once the TPLs are build, you need to need to appropriate module, i.e.
           boost, dealii, and, if necessary, mpi (You may also need to load metis
           because dealii depends on suite-sparse which depends on metis).
          </p>
          <p>
          To install <i>adamantine</i>, simply run:
          <ul>
            <li> <strong> cmake -DCMAKE_BUILD_TYPE=Release /path/to/adamantine
              </strong> </li>
            <li> <strong> make </strong> </li>
          </ul>
          This should create a <i>/bin</i> subdirectory with an <i>adamantine</i>
          executable and an example of an input file <i>input.info</i>. The
          different options accepted by cmake are:
          <ul>
            <li> -DCMAKE_BUILD_TYPE=Debug/Release </li>
            <li> -DADAMANTINE_ENABLE_TESTS=ON/OFF </li>
            <li> -DDEAL_II_DIR=/path/to/dealii (If you use spack this variable is
              set when you load the module) </li>
            <li> -DBOOST_DIR=/path/to/boost (If you use spack this variable is
              set when you load the module) </li>
          </ul>
          Note that for all the tests to pass you also need clang-format 3.7. If
          you don't the indentation test that checks the format of the source code 
          will not pass.
          </p>
        <h2>Run</h2>
          <p>
          After installing <i>adamantine</i>, you can run a simulation using:
          <ul>
            <li> <strong> ./adamantine --input-file=input.info </strong> </li>
          </ul>
          Note that the name of the input can be chosen arbitrary.
          <i>my_input_file</i> is as valid as <i>input.info</i> <br>
          </p>
          <h3>Input</h3>
            <p>
            The following options are available:
            </p>
            <h4>geometry</h4>
            <p>
            <ul>
              <li> <strong> dim </strong> the dimension of the problem (2 or 3)
              </li>
              <li> <strong> length </strong> the length of the domain in
                meters </li>
              <li> <strong> height </strong> the height of the domain in
                meters </li>
              <li> <strong> width </strong> the width of the domain in meters
                (only in 3D) </li>
              <li> <strong> length_divisions </strong> number of cell layers in
                length (default value: 10) </li>
              <li> <strong> height_divisions </strong> number of cell layers in
                height (default value: 10) </li>
              <li> <strong> width_divisions </strong> number of cell layers in
                width (only in 3D) (default value: 10) </li>
            </ul>
            </p>
            <h4>refinement</h4>
            <p>
            <ul>
              <li> <strong> n_heat_refinements </strong> number of
                coarsening/refinement to execute (defaul value: 2) </li>
              <li> <strong> heat_cell_ratio </strong> this is the ratio (n new
                cells)/(n old cells) after heat refinement (default value: 1)
              </li>
              <li> <strong> n_beam_refinements </strong> number of times the
                cells on the paths of the beams are refined (default value: 2)
              </li>
              <li> <strong> max_level </strong> maximum number of times  a cell
                can be refined </li>
              <li> <strong> verbose </strong> print the number of degrees of
                freedom after refinement (default value: false)
            </ul>
            </p>
            <h4>materials</h4>
            <p>
            <ul>
              <li> <strong> n_materials </strong> number of materials </li>
              <li> <strong> material_X </strong> property tree for the material with
                number X </li>
              <li> <strong> material_X.Y </strong> property tree where Y is
                either liquid, powder, or solid (optional) </li>
              <li> <strong> material.X.Y.Z </strong> Z is either  density, 
                specific_heat or thermal conductivity (optional) </li>
              <li> <strong> material.X.A </strong> A is either solidus,
                liquidus, or latent_heat </li>
            </ul>
            </p>
            <h4>sources</h4>
            <p>
            <ul>
              <li> <strong> n_beams </strong> number of electron beams </li>
              <li> <strong> beam_X </strong> property tree for the beam with
                number X </li>
              <li> <strong> beam_X.depth </strong> maximum depth reached by the
                electron beam in meter </li>
              <li> <strong> beam_X.energy_conversion_efficiency </strong>
                energy conversion efficiency of the beam. Number between 0 and
                1. </li>
              <li> <strong> beam_X.control_efficiency </strong> control 
                efficiency of the neam. Number between 0 and 1. </li>
              <li> <strong> beam_X.diameter </strong> diameter of the beam in
                meter (default value: 2e-3). </li>
              <li> <strong> beam_X.max_power </strong> power of the beam in
                watt (optional). </li>
              <li> <strong> beam_X.current </strong> current used to generate
                the electron beam in ampere (optional). </li>
              <li> <strong> beam_X.voltage </strong> voltage used to generate
                the electron beam in volt (optional). </li>
              <li> <strong> beam_X.abscissa </strong> abscissa of the position
                of the beam over time.
              <li> <strong> beam_X.ordinate </strong> ordinate of the position
                of the beam over time (only in 3D). </li>
            </ul>
            </p>
            <h4>time_stepping</h4>
            <p>
            <ul>
              <li> <strong> method </strong> name of the method to use for the
                time integration. </li>
              <li> <strong> duration </strong> duration of the simulation in
                second. </li>
              <li> <strong> time_step </strong> length of the time steps used
                for the simulation in second. </li>
              <li> <strong> max_iteration </strong> if the method used is
                implicit, maximum number of iterations of the solver (default
                value: 1000). </li>
              <li> <strong> tolerance </strong> if the method used is implicit,
                tolerance of the solver (default value 1e-12). </li>
              <li> <strong> right_preconditioner </strong> if the method used
                is implicit, set left or right preconditioning for the solver
                (default value: false). </li>
              <li> <strong> n_tmp_vectors </strong> if the method used is
                implicit and the solver is GMRES, maximum number of temporary 
                vectors to save (default value: 30). </li>
              <li> <strong> newton_max_iteration </strong> if the method used
                is implicit, maximum number of iterations of the Newton solver
                (default value: 100). </li>
              <li> <strong> newton_tolerance </strong> if the method used is
                implicit, tolerance of the Newton solver (default value: 1e-6).
              </li>
              <li> <strong> jfnk </strong> if the method used is implicit, set
                Jacobian-Free Newton Krylov method on or off (default value:
                false) </li>
            </ul>
            </p>
            <h4>post_processor</h4>
            <p>
            <ul>
              <li> <strong> file_name </strong> prefix of output files. </li>
            </ul>
            </p>
            <h4>discretization</h4>
            <p>
            <ul>
              <li> <strong> fe_degree </strong> degree of the finite element
                used. </li>
              <li> <strong> quadrature </strong> quadrature used (default
                value: gauss). </li>
            </ul>
            </p>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/Rombur">Rombur</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>

